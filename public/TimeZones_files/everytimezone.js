// Generated by CoffeeScript 1.6.1
(function() {
  var $, activeg, android, android4, anim, appCache, barCache, barHeight, barWidth, body, bottomg, boxBitmapCache, cancelSelectionOnThisTouch, canvas, chrome, cities, clickyScript, clickyScriptInterval, context, css, date, defaultg, dragging, drawBox, formatDate, formattime, gradientForBar, height, html, ie, ignoreNextHashChange, ios, labelsLeft, lastTouchX, lastTouchY, localg, localoffset, months, move, moz, offsetMinutes, opera, options, pixelRatio, recalculate, recalculateGrid, refresh, render, roundedCorner, roundg, rowHeight, scrollTopStart, serializeCities, serializeState, setCanvasSize, setDate, setDefaultOptions, setup, setupGradients, supportsTouch, time, timezoneCache, timezonesLabelAlign, topg, touchStartAt, touchStartX, touchStartY, transitionstr, translateX, transprop, transstr, twitterScript, ua, unserializeCities, updateCurrentTime, updateLocalTime, updateLocalTimeCache, updateSettingsFromHash, updateTimeSelectorPosition, updateURL, webkit, width;

  cities = [];

  offsetMinutes = 0;

  unserializeCities = function(visibleCities) {
    var bit, city, _i, _len, _results;
    if (visibleCities === 0) {
      visibleCities = 65535;
    }
    bit = 0;
    cities = [];
    _results = [];
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      city = data[_i];
      _results.push((function(city) {
        cities.push(city);
          city[3] = true;
        //if (visibleCities & (1 << bit)) {
         // cities.push(city);
        //  city[3] = true;
        //}
        return bit += 1;
      })(city));
    }
    return _results;
  };

  serializeCities = function() {
    var bit, city, value, _fn, _i, _len;
    bit = 0;
    value = 0;
    _fn = function(city) {
      if (city[3]) {
        value += 1 << bit;
      }
      return bit += 1;
    };
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      city = data[_i];
      _fn(city);
    }
    return value.toString(36);
  };

  options = {};

  setDefaultOptions = function() {
    var currentTime, currentTimeOffset, now;
    now = new Date;
    currentTime = now.getUTCHours() * 60 + now.getUTCMinutes();
    currentTimeOffset = currentTime - 12 * 60;
    return options = {
      date: now,
      offset: currentTimeOffset,
      cities: 65535
    };
  };

  setDefaultOptions();

  updateSettingsFromHash = function() {
    var dateParts, serializedCities, serializedDate, serializedOffset, _ref;
    if (location.hash === "") {
      return;
    }
    _ref = location.hash.slice(1).split(','), serializedDate = _ref[0], serializedOffset = _ref[1], serializedCities = _ref[2];
    dateParts = serializedDate.split('-');
    options.date = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
    options.offset = parseInt(serializedOffset);
    return options.cities = parseInt(serializedCities, 36);
  };

  if ((navigator.standalone == null) && !navigator.standalone) {
    updateSettingsFromHash();
  }

  unserializeCities(options.cities);

  offsetMinutes = options.offset;

  ignoreNextHashChange = false;

  $ = function(id) {
    return document.getElementById(id);
  };

  html = function(id, html) {
    if (html == null) {
      html = '';
    }
    return ($(id) || id).innerHTML = html;
  };

  css = function(id, style) {
    return ($(id) || id).style.cssText += ';' + style;
  };

  ua = navigator.userAgent;

  ios = ua.match(/(iPhone\sOS)\s([\d_]+)/) || ua.match(/(iPad\sOS)\s([\d_]+)/);

  webkit = ua.indexOf('AppleWebKit/') > -1;

  moz = ua.indexOf('Gecko') > -1 && !webkit;

  opera = ua.indexOf('Opera') > -1;

  ie = ua.indexOf('MSIE') > -1;

  chrome = ua.indexOf('Chrome') > -1;

  android = ua.match(/(Android)\s+([\d.]+)/) && webkit;

  android4 = ua.match(/(Android)\s+4([\d.]+)/) && webkit;

  transprop = webkit ? 'webkitTransform' : ie ? 'msTransform' : moz ? 'MozTransform' : opera ? 'OTransform' : 'transform';

  transstr = webkit ? '-webkit-transform' : ie ? '-ms-transform' : moz ? '-moz-transform' : opera ? '-o-transform' : void 0;

  transitionstr = webkit ? '-webkit-transition' : ie ? '-ms-transition' : moz ? '-moz-transition' : opera ? '-o-transition' : void 0;

  anim = function(id, transform, opacity, dur) {
    if (opacity == null) {
      opacity = 1;
    }
    if (dur == null) {
      dur = 0.5;
    }
    return css(id, "" + transitionstr + ":all " + dur + "s; " + transstr + ":    " + transform + "; opacity:" + opacity);
  };

  translateX = function(element, x, anim) {
    if (anim == null) {
      anim = false;
    }
    if (isNaN(x)) {
      return;
    }
    element = $(element);
    if (anim) {
      element.style.cssText += ";" + transitionstr + ":all 0.4s;";
    }
    return element.style[transprop] = webkit && supportsTouch ? "translate3d(" + x + "px,0,0)" : "translate3d(" + x + "px,0,0)";
  };

  timezonesLabelAlign = 'left';

  months = 'January February March April May June July August September October November December'.split(' ');

  Date.prototype.addDays = function(days) {
    return new Date(this.getTime() + (days * 1000 * 60 * 60 * 24));
  };

  Function.prototype.delay = function(seconds) {
    return setTimeout(this, seconds * 1000);
  };

  supportsTouch = document.createTouch != null;

  pixelRatio = window.devicePixelRatio || 1;

  body = $('body');

  canvas = $('canvas');

  context = canvas.getContext('2d');

  width = height = barWidth = barHeight = rowHeight = labelsLeft = null;

  defaultg = activeg = localg = roundg = topg = bottomg = null;

  date = localoffset = time = null;

  barCache = timezoneCache = null;

  context.save();

  if (supportsTouch) {
    body.className = 'supports-touch';
  }

  if (chrome) {
    body.className = 'chrome';
  }

  if (ios) {
    body.className = 'supports-touch with-initial-animation';
  }

  setCanvasSize = function(canvas, width, height) {
    canvas.setAttribute('width', width * pixelRatio);
    canvas.setAttribute('height', height * pixelRatio);
    return css(canvas, "height:" + height + "px; width:" + width + "px");
  };

  setup = function() {
    var actionIcon, editIcon, populateTimeZoneSelect, svgFromString;
    populateTimeZoneSelect = function() {
      var index, item, select, _i, _len;
      select = $('select_timezones');
      index = -1;
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        item = data[_i];
        select.appendChild(new Option("" + item[1] + " (" + item[2] + ")", index += 1, false, item[3]));
      }
      return select.onchange = function() {
        var bit, city, value, _fn, _j, _len1;
        bit = 0;
        value = 0;
        _fn = function(city) {
          if (select.options[bit].selected) {
            value += 1 << bit;
          }
          return bit += 1;
        };
        for (_j = 0, _len1 = data.length; _j < _len1; _j++) {
          city = data[_j];
          _fn(city);
        }
        unserializeCities(value);
        refresh();
        return updateURL();
      };
    };
    svgFromString = function(svg) {
      return document.adoptNode((new DOMParser).parseFromString(svg, 'text/xml').firstChild);
    };
    actionIcon = function(container) {
      var svg;
      svg = '  <svg class="action" width="12px" height="10px" viewBox="0 0 12 10" version="1.1" xmlns="http://www.w3.org/2000/svg">\n<g><path d="M12,3.5L8,0v2.25c0,0-5,0.75-5,5C4.5,5,8,4.75,8,4.75V7L12,3.5z"/></g>\n<g><polygon points="10,7 9,8 9,9 1,9 1,3 3.5,3 4.5,2 0,2 0,10 10,10"/></g>\n</svg>';
      return container.appendChild(svgFromString(svg));
    };
    editIcon = function(container) {
      var svg;
      svg = '      <svg class="action" width="36px" height="36px" viewBox="0 0 36 36" version="1.1" xmlns="http://www.w3.org/2000/svg">\n        <path fill="#FFFFFF" d="M23.077,10.154h-1.106c-0.508,0-1.047-0.397-1.198-0.883l-0.636-1.545c-0.239-0.447-0.141-1.107,0.216-1.467\nl0.788-0.785c0.359-0.359,0.359-0.947,0-1.307l-1.309-1.305c-0.358-0.359-0.945-0.359-1.305,0l-0.788,0.785\nc-0.356,0.358-1.019,0.457-1.467,0.217l-1.543-0.637c-0.483-0.149-0.881-0.688-0.881-1.197V0.924C13.849,0.417,13.432,0,12.924,0\nh-1.847c-0.508,0-0.924,0.417-0.924,0.924v1.107c0,0.509-0.396,1.048-0.881,1.197L7.728,3.865c-0.449,0.24-1.106,0.143-1.466-0.217\nL5.474,2.863c-0.359-0.359-0.945-0.359-1.304,0L2.864,4.168c-0.36,0.359-0.36,0.947,0,1.307L3.647,6.26\nc0.36,0.359,0.459,1.02,0.217,1.467L3.229,9.273c-0.152,0.484-0.688,0.881-1.197,0.881H0.924C0.416,10.154,0,10.568,0,11.077v1.846\nc0,0.509,0.416,0.925,0.924,0.925h1.108c0.509,0,1.045,0.396,1.195,0.881l0.637,1.547c0.241,0.447,0.144,1.109-0.217,1.467\nl-0.785,0.785c-0.358,0.359-0.358,0.947,0,1.307l1.308,1.307c0.358,0.357,0.944,0.357,1.304,0l0.788-0.787\nc0.357-0.357,1.017-0.455,1.462-0.213l1.549,0.635c0.485,0.152,0.881,0.689,0.881,1.197v1.105c0,0.506,0.416,0.922,0.924,0.922\nh1.847c0.508,0,0.925-0.416,0.925-0.922v-1.105c0-0.508,0.397-1.045,0.881-1.197l1.548-0.635c0.446-0.242,1.107-0.145,1.467,0.213\nl0.783,0.787c0.359,0.357,0.946,0.357,1.305,0l1.309-1.307c0.359-0.359,0.359-0.947,0-1.307l-0.788-0.785\nc-0.356-0.357-0.455-1.02-0.216-1.467l0.636-1.547c0.151-0.484,0.693-0.881,1.198-0.881h1.106c0.509,0,0.923-0.414,0.923-0.923\nv-1.848C24,10.568,23.586,10.154,23.077,10.154 M16.619,11.999c0,2.55-2.066,4.614-4.615,4.614c-2.552,0-4.617-2.064-4.617-4.614\nc0-2.549,2.065-4.615,4.617-4.615C14.553,7.384,16.619,9.45,16.619,11.999"/>\n      </svg>';
      return container.appendChild(svgFromString(svg));
    };
    actionIcon($('action_icon'));
    editIcon($('edit_icon'));
    if (navigator.standalone) {
      body.className += " standalone";
    }
    populateTimeZoneSelect();
    if (supportsTouch) {
      html('shortcut_link', 'tap &amp; hold to share');
      if (android) {
        return $('tap_to_add').style.display = 'none';
      }
    } else {
      return html('shortcut_link', 'link to this page');
    }
  };

  setupGradients = function() {
    var stop, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    defaultg = context.createLinearGradient(0, 0, barWidth * pixelRatio, 0);
    activeg = context.createLinearGradient(0, 0, barWidth * pixelRatio, 0);
    localg = context.createLinearGradient(0, 0, barWidth * pixelRatio, 0);
    roundg = context.createLinearGradient(0, 0, 0, barHeight * pixelRatio);
    topg = context.createLinearGradient(0, 0, 0, barHeight * pixelRatio);
    bottomg = context.createLinearGradient(0, barHeight * pixelRatio, 0, 0);
    _ref = [[0, '#4b4c4d'], [0.2499, '#4b4c4d'], [0.25, '#575b5c'], [0.3299, '#575b5c'], [0.33, '#6b7071'], [0.7499, '#6b7071'], [0.75, '#575b5c'], [0.9099, '#575b5c'], [0.91, '#4b4c4d'], [1, '#4b4c4d']];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      stop = _ref[_i];
      defaultg.addColorStop(stop[0], stop[1]);
    }
    _ref1 = [[0, '#5485b1'], [0.2499, '#5485b1'], [0.25, '#3cafc5'], [0.3299, '#3cafc5'], [0.33, '#55c8e4'], [0.7499, '#55c8e4'], [0.75, '#3cafc5'], [0.9099, '#3cafc5'], [0.91, '#5485b1'], [1, '#5485b1']];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      stop = _ref1[_j];
      activeg.addColorStop(stop[0], stop[1]);
    }
    _ref2 = [[0, '#8abb29'], [0.2499, '#8abb29'], [0.25, '#a5df3b'], [0.3299, '#a5df3b'], [0.33, '#b8ff41'], [0.7499, '#b8ff41'], [0.75, '#a5df3b'], [0.9099, '#a5df3b'], [0.91, '#8abb29'], [1, '#8abb29']];
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      stop = _ref2[_k];
      localg.addColorStop(stop[0], stop[1]);
    }
    roundg.addColorStop(0, 'rgba(0,0,0,0)');
    roundg.addColorStop(1, 'rgba(0,0,0,0.4)');
    topg.addColorStop(0, 'rgba(255,255,255,0.3)');
    topg.addColorStop(0.025, 'rgba(255,255,255,0)');
    bottomg.addColorStop(0, 'rgba(255,255,255,0.3)');
    return bottomg.addColorStop(0.025, 'rgba(255,255,255,0)');
  };

  roundedCorner = function(w, h, rad, ctx) {
    if (ctx == null) {
      ctx = context;
    }
    ctx.beginPath();
    ctx.moveTo(rad, 0);
    ctx.lineTo(w - rad, 0);
    ctx.quadraticCurveTo(w, 0, w, rad);
    ctx.lineTo(w, h - rad);
    ctx.quadraticCurveTo(w, h, w - rad, h);
    ctx.lineTo(rad, h);
    ctx.quadraticCurveTo(0, h, 0, h - rad);
    ctx.lineTo(0, rad);
    ctx.quadraticCurveTo(0, 0, rad, 0);
    return ctx.fill();
  };

  boxBitmapCache = {};

  drawBox = function(x, y, gradient) {
    var cacheCanvas, ctx, gradientName, h, w;
    if (gradient == null) {
      gradient = defaultg;
    }
    if (gradient === defaultg) {
      gradientName = "default";
    }
    if (gradient === activeg) {
      gradientName = "active";
    }
    if (gradient === localg) {
      gradientName = "local";
    }
    if (!boxBitmapCache[gradientName]) {
      cacheCanvas = document.createElement("canvas");
      setCanvasSize(cacheCanvas, barWidth * pixelRatio, barHeight * pixelRatio);
      ctx = cacheCanvas.getContext("2d");
      w = (barWidth - 2) * pixelRatio;
      h = barHeight * pixelRatio;
      ctx.fillStyle = gradient;
      ctx.clearRect(0, 0, w, h);
      roundedCorner(w, h, h / 2.5, ctx);
      ctx.fillStyle = roundg;
      roundedCorner(w, h, h / 2.5, ctx);
      ctx.fillStyle = topg;
      roundedCorner(w, h, h / 2.5, ctx);
      ctx.fillStyle = bottomg;
      roundedCorner(w, h, h / 2.5, ctx);
      boxBitmapCache[gradientName] = cacheCanvas;
    }
    context.clearRect(x, y, barWidth, barHeight);
    return context.drawImage(boxBitmapCache[gradientName], x, y, barWidth * pixelRatio, barHeight * pixelRatio);
  };

  setDate = function(newDate) {
    if (newDate == null) {
      newDate = options.date;
    }
    date = newDate;
    localoffset = -(date.getTimezoneOffset() / 60);
    return time = date.getUTCHours() * 60 + date.getUTCMinutes();
  };

  recalculate = function() {
    var _ref;
    _ref = [window.innerWidth, cities.length * 60 + 350], width = _ref[0], height = _ref[1];
    barWidth = width / 3;
    if (width > 480) {
      height -= 100;
    }
    rowHeight = 60;
    barHeight = 24;
    labelsLeft = width / 2 - barWidth * 3 / 2;
    setCanvasSize(canvas, width, height);
    context.restore();
    context.save();
    context.scale(pixelRatio, pixelRatio);
    context.clearRect(0, 0, width, height);
    css('header', "width:" + (barWidth * 3) + "px;left:" + (width / 2 - barWidth * 3 / 2) + "px");
    css('line', "height:" + (height - 82 - 100) + "px");
    css('cline', "height:" + (height - 82 - 100) + "px");
    return css('wrapper', "height:" + height + "px");
  };

  gradientForBar = function(cityOffset, offset) {
    var hour;
    hour = offset + 12;
    if (hour >= 0 && hour < 24) {
      if (cityOffset === localoffset) {
        return localg;
      } else {
        return activeg;
      }
    } else {
      return defaultg;
    }
  };

  recalculateGrid = function() {
    var center, city, datesHTML, row, timesHTML, timezone, timezonesHTML, top, _fn, _i, _j, _len, _len1, _results;
    top = 115;
    row = 0;
    center = width / 2 - barWidth / 2;
    timezonesHTML = '';
    datesHTML = '';
    timesHTML = '';
    barCache = [];
    timezoneCache = [];
    _fn = function(city) {
      var leftOffset, topOffset;
      leftOffset = -city[0] / 24 * barWidth;
      topOffset = row * rowHeight + top;
      barCache.push([
        {
          left: leftOffset + center - barWidth * 2,
          top: topOffset + 20,
          gradient: gradientForBar(city[0], city[0] + 48 + offsetMinutes / 60)
        }, {
          left: leftOffset + center - barWidth,
          top: topOffset + 20,
          gradient: gradientForBar(city[0], city[0] + 24 + offsetMinutes / 60)
        }, {
          left: leftOffset + center,
          top: topOffset + 20,
          gradient: gradientForBar(city[0], city[0] + offsetMinutes / 60)
        }, {
          left: leftOffset + center + barWidth,
          top: topOffset + 20,
          gradient: gradientForBar(city[0], city[0] - 24 + offsetMinutes / 60)
        }, {
          left: leftOffset + center + barWidth * 2,
          top: topOffset + 20,
          gradient: gradientForBar(city[0], city[0] - 48 + offsetMinutes / 60)
        }
      ]);
      timezoneCache.push({
        offset: city[0]
      });
      drawBox(barCache[row][1].left, barCache[row][1].top, barCache[row][1].gradient);
      drawBox(barCache[row][2].left, barCache[row][2].top, barCache[row][2].gradient);
      drawBox(barCache[row][3].left, barCache[row][3].top, barCache[row][3].gradient);
      timezonesHTML += "<div style='left:" + labelsLeft + "px;top:" + (topOffset - 2) + "px'>" + city[1] + " <small>" + city[2] + "</small></div>";
      timesHTML += "<div id='time_" + row + "' style='top:" + (topOffset - 2) + "px'></div>";
      datesHTML += "<div style='left:" + barCache[row][1].left + "px;top:" + barCache[row][1].top + "px;width:" + barWidth + "px'>\n  " + (formatDate(date.addDays(-1))) + "\n</div>\n<div style='left:" + barCache[row][2].left + "px;top:" + barCache[row][2].top + "px;width:" + barWidth + "px'>\n  " + (formatDate(date.addDays(0))) + "\n</div>\n<div style='left:" + barCache[row][3].left + "px;top:" + barCache[row][3].top + "px;width:" + barWidth + "px'>\n  " + (formatDate(date.addDays(1))) + "\n</div>";
      return row += 1;
    };
    for (_i = 0, _len = cities.length; _i < _len; _i++) {
      city = cities[_i];
      _fn(city);
    }
    html('timezones', timezonesHTML);
    html('dates', datesHTML);
    html('times', timesHTML);
    row = 0;
    _results = [];
    for (_j = 0, _len1 = timezoneCache.length; _j < _len1; _j++) {
      timezone = timezoneCache[_j];
      _results.push((function(timezone) {
        timezone.timeEl = $("time_" + row);
        return row += 1;
      })(timezone));
    }
    return _results;
  };

  render = function() {
    var city, row, _i, _len, _results;
    row = 0;
    _results = [];
    for (_i = 0, _len = cities.length; _i < _len; _i++) {
      city = cities[_i];
      _results.push((function(city) {
        var bar, barg0, barg1, barg2, barg3, barg4;
        bar = barCache[row];
        barg0 = gradientForBar(city[0], city[0] + 48 + offsetMinutes / 60);
        barg1 = gradientForBar(city[0], city[0] + 24 + offsetMinutes / 60);
        barg2 = gradientForBar(city[0], city[0] + offsetMinutes / 60);
        barg3 = gradientForBar(city[0], city[0] - 24 + offsetMinutes / 60);
        barg4 = gradientForBar(city[0], city[0] - 48 + offsetMinutes / 60);
        if (bar[1].gradient !== barg1) {
          drawBox(bar[1].left, bar[1].top, bar[1].gradient = barg1);
        }
        if (bar[2].gradient !== barg2) {
          drawBox(bar[2].left, bar[2].top, bar[2].gradient = barg2);
        }
        if (bar[3].gradient !== barg3) {
          drawBox(bar[3].left, bar[3].top, bar[3].gradient = barg3);
        }
        return row += 1;
      })(city));
    }
    return _results;
  };

  refresh = function() {
    boxBitmapCache = {};
    recalculate();
    setupGradients();
    recalculateGrid();
    render();
    updateTimeSelectorPosition();
    return updateCurrentTime();
  };

  window.onorientationchange = refresh;

  window.onresize = refresh;

  dragging = false;

  formatDate = function(date) {
    return "" + months[date.getMonth()] + " " + (date.getDate());
  };

  formattime = function(time) {
    var mins, suffix, _ref;
    if (time < 0) {
      time = 24 - Math.abs(time % 24);
    }
    if (time >= 24) {
      time = time % 24;
    }
    mins = Math.abs(((time * 60) % 60) | 0);
    if (mins < 10) {
      mins = "0" + mins;
    }
    time = time | 0;
    suffix = "am";
    if (time >= 12) {
      _ref = [time % 12, "pm"], time = _ref[0], suffix = _ref[1];
    }
    if (time === 0) {
      time = 12;
    }
    return "" + time + ":" + mins + " " + suffix;
  };

  updateCurrentTime = function(selectTime) {
    var currentTime, currentTimeOffset, localOffset, now, pageX;
    now = new Date;
    currentTime = now.getUTCHours() * 60 + now.getUTCMinutes();
    currentTimeOffset = currentTime - 12 * 60;
    localOffset = -(now.getTimezoneOffset() / 60);
    pageX = width / 2 + currentTimeOffset / 60 / 24 * barWidth;
    css('cnow', "left:" + pageX + "px");
    html('clocaltime', formattime(currentTimeOffset / 60 + localoffset + 12));
    if (selectTime) {
      css('now', "left:" + pageX + "px");
      return html('localtime', formattime(currentTimeOffset / 60 + localoffset + 12));
    }
  };

  updateLocalTimeCache = null;

  updateLocalTime = function(force) {
    var timezone, _i, _len, _results;
    if (!force && updateLocalTimeCache === offsetMinutes) {
      return;
    }
    updateLocalTimeCache = offsetMinutes;
    html('localtime', formattime(offsetMinutes / 60 + 12 + localoffset));
    _results = [];
    for (_i = 0, _len = timezoneCache.length; _i < _len; _i++) {
      timezone = timezoneCache[_i];
      _results.push((function(timezone) {
        return timezone.timeEl.innerHTML = formattime(offsetMinutes / 60 + 12 + timezone.offset);
      })(timezone));
    }
    return _results;
  };

  serializeState = function() {
    return "" + (date.getFullYear()) + "-" + (date.getMonth() + 1) + "-" + (date.getDate()) + "," + offsetMinutes + "," + (serializeCities());
  };

  updateTimeSelectorPosition = function(minutes) {
    var pageX, timesPos;
    if (minutes == null) {
      minutes = offsetMinutes;
    }
    pageX = width / 2 + minutes / 60 / 24 * barWidth;
    css('now', "left:" + pageX + "px");
    timesPos = pageX-150;
    if (pageX > width - 100) {
      timesPos -= 85;
    }
    css('times', "left:" + timesPos + "px");
    if (pageX < 200 && timezonesLabelAlign === 'left') {
      translateX('timezones', width - (width <= 480 ? 120 : 200), true);
      timezonesLabelAlign = 'right';
    }
    if (pageX > (width - (width <= 480 ? 200 : 300)) && timezonesLabelAlign === 'right') {
      translateX('timezones', 0, true);
      return timezonesLabelAlign = 'left';
    }
  };

  updateURL = function() {
    var state;
    state = serializeState();
    ignoreNextHashChange = true;
    location.hash = state;
    return $('shortcut_link').setAttribute('href', "http://everytimezone.com/#" + state);
  };

  touchStartX = touchStartY = -1;

  lastTouchX = lastTouchY = -1;

  touchStartAt = scrollTopStart = -1;

  cancelSelectionOnThisTouch = false;

  move = function(event) {
    var originalOffsetMinutes, pageX;
    if (!dragging) {
      return;
    }
    pageX = event.pageX;
    if (event.touches != null) {
      pageX = lastTouchX;
    }
    if (pageX < 50) {
      pageX = 50;
    }
    if (pageX > width - 50) {
      pageX = width - 50;
    }
    offsetMinutes = Math.round(((pageX - width / 2) / barWidth) * 24 * 60);
    originalOffsetMinutes = offsetMinutes;
    offsetMinutes -= offsetMinutes % 15;
    render();
    updateTimeSelectorPosition(originalOffsetMinutes);
    if (!android) {
      updateLocalTime();
    }
    if (event.touches != null) {
      return event.preventDefault();
    }
  };

  key('left', function() {
    offsetMinutes -= 15;
    offsetMinutes -= offsetMinutes % 15;
    render();
    updateTimeSelectorPosition();
    if (!android) {
      return updateLocalTime();
    }
  });

  key('right', function() {
    offsetMinutes += 15;
    offsetMinutes -= offsetMinutes % 15;
    render();
    updateTimeSelectorPosition();
    if (!android) {
      return updateLocalTime();
    }
  });

  body[supportsTouch ? "ontouchstart" : "onmousedown"] = function(event) {
    var element, _ref;
    element = event.target;
    if (element.nodeType !== 1) {
      element = element.parentNode;
    }
    if ((element.tagName != null) && ((_ref = element.tagName) === 'A' || _ref === 'IMG' || _ref === 'SELECT' || _ref === 'INPUT')) {
      return;
    }
    if (event.touches != null) {
      scrollTopStart = document.body.scrollTop;
      touchStartAt = Date.now();
      touchStartX = lastTouchX = event.touches[0].pageX;
      touchStartY = lastTouchY = event.touches[0].pageY;
      if (event.touches[0].pageY < 50) {
        return;
      }
    }
    return dragging = true;
  };

  body[supportsTouch ? "ontouchmove" : "onmousemove"] = function(event) {
    var _ref;
    if (event.touches != null) {
      lastTouchX = event.touches[0].pageX;
      lastTouchY = event.touches[0].pageY;
      if (!(!cancelSelectionOnThisTouch && document.body.scrollTop === scrollTopStart)) {
        cancelSelectionOnThisTouch = true;
        return;
      }
      if ((Date.now() - touchStartAt) < 50) {
        return;
      }
      if ((-10 < (_ref = touchStartX - lastTouchX) && _ref < 10)) {
        return;
      }
    }
    return move(event);
  };

  body[supportsTouch ? "ontouchend" : "onmouseup"] = function(event) {
    if (supportsTouch) {
      if (!cancelSelectionOnThisTouch && scrollTopStart === document.body.scrollTop) {
        move(event);
      }
    } else {
      move(event);
    }
    touchStartX = touchStartY = lastTouchX = lastTouchY = touchStartAt = scrollTopStart = -1;
    cancelSelectionOnThisTouch = false;
    dragging = false;
    return updateURL();
  };

  $('footer')['onclick'] = function() {
    return location.href = 'http://letsfreckle.com/';
  };

  window.onhashchange = function() {
    if (ignoreNextHashChange) {
      ignoreNextHashChange = false;
      return;
    }
    updateSettingsFromHash();
    unserializeCities(options.cities);
    offsetMinutes = options.offset;
    setDate();
    updateTimeSelectorPosition();
    updateLocalTime(true);
    return refresh();
  };

  setup();

  setDate();

  refresh();

  updateCurrentTime(true);

  updateLocalTime(true);

  updateTimeSelectorPosition();

  setInterval(updateCurrentTime, 1000);

  if (android) {
    setInterval(updateLocalTime, 350);
  }

  scrollTo(0, 1);

  if (ios) {
    (function() {
      return anim('wrapper', 'scale(1)');
    }).delay(0.5);
  }

  if (window.applicationCache != null) {
    appCache = window.applicationCache;
    appCache.addEventListener('updateready', function() {
      if (confirm("There's a newer version of Every Time Zone available, reload now?")) {
        appCache.swapCache();
        return location.reload();
      }
    }, false);
  }

  if ((navigator.onLine == null) || navigator.onLine) {
    twitterScript = document.createElement('script');
    twitterScript.innerHTML = "!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=\"//platform.twitter.com/widgets.js\";fjs.parentNode.insertBefore(js,fjs);}}(document,\"script\",\"twitter-wjs\")";
    clickyScript = document.createElement('script');
    clickyScript.src = "//static.getclicky.com/js";
    $('body').appendChild(twitterScript);
    $('body').appendChild(clickyScript);
    clickyScriptInterval = setInterval(function() {
      if (typeof clicky === "undefined" || clicky === null) {
        return;
      }
      clearInterval(clickyScriptInterval);
      try {
        return clicky.init(204109);
      } catch (_error) {}
    }, 1000);
  }

}).call(this);
